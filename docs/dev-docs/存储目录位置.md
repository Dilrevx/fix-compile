这是一个非常好的工程化问题。对于一个成熟的 Python CLI 项目，我们需要区分 **“开发时的目录结构”**（源码库长什么样）和 **“运行时的目录结构”**（安装到用户电脑后，数据存在哪）。

这是现代 Python CLI 项目（尤其是使用 `uv` / `hatch` / `poetry` 管理时）的标准最佳实践：

### 一、 开发时的项目目录结构 (Repository Structure)

这是你在 GitHub 仓库里看到的结构。推荐使用 `src-layout`。

```text
fix-compile/
├── pyproject.toml       # 项目配置、依赖定义
├── README.md            # 项目说明
├── .gitignore           # Git 忽略文件
├── .pre-commit-config.yaml # 代码检查钩子
├── src/                 # 核心源码
│   └── fix_compile/     # 包名（注意用下划线）
│       ├── __init__.py
│       ├── main.py      # CLI 入口
│       ├── config.py    # 配置定义 (Pydantic Settings)
│       ├── analyzer.py  # 核心逻辑
│       ├── executor.py  # 核心逻辑
│       └── templates/   # 【内置资源】如果你有内置的 Prompt 或配置模板放这里
│           ├── system_prompt.txt
│           └── .env.example
├── tests/               # 测试代码
│   ├── __init__.py
│   ├── test_analyzer.py
│   └── test_cli.py
└── examples/            # 【示例】给用户看的 Demo
    ├── broken_docker/
    │   └── Dockerfile
    └── scripts/
        └── usage_demo.py

```

---

### 二、 运行时的文件存储位置 (Runtime Storage)

当用户 `pip install fix-compile` 并运行后，你的程序会产生各种文件（缓存、日志、用户配置）。

**❌ 绝对不要做的事：**

* 不要在项目源码目录下写文件（`src/fix_compile/logs/`），因为在 `site-packages` 里通常是只读的。
* 不要直接往用户主目录写文件（`~/fix-compile.log`），这会弄脏用户的 Home 目录，非常不礼貌。

**✅ 最佳实践：遵循 XDG 标准 (使用 `platformdirs`)**
不同的操作系统（Linux, Mac, Windows）有不同的标准目录来存放这些文件。Python 库 `platformdirs` 帮你屏蔽了这些差异。

你需要安装它：

```bash
uv add platformdirs

```

#### 1. 用户配置文件 (User Config)

* **用途**：存放用户修改后的配置，如 `config.json`, `.env` (如果不想放当前目录)。
* **Linux**: `~/.config/fix-compile/`
* **Mac**: `~/Library/Application Support/fix-compile/`
* **Windows**: `C:\Users\User\AppData\Local\fix-compile\`

#### 2. 缓存文件 (Cache)

* **用途**：存放可以随时删除、丢失也不影响程序运行的数据。比如下载的临时模型、API 响应缓存、Docker build 上下文的临时哈希。
* **Linux**: `~/.cache/fix-compile/`
* **Mac**: `~/Library/Caches/fix-compile/`

#### 3. 数据文件 (User Data)

* **用途**：存放程序运行产生的持久化数据（不适合让用户直接编辑的）。比如 SQLite 数据库、历史记录 (history.db)。
* **Linux**: `~/.local/share/fix-compile/`

#### 4. 日志文件 (Logs)

* **用途**：`app.log`, `error.log`。
* **Linux**: `~/.cache/fix-compile/log/` 或 `~/.local/state/fix-compile/log/`

---

### 三、 代码实现示例

建议在你的项目中创建一个 `paths.py` 或 `utils.py` 专门管理这些路径，确保统一。

```python
# src/fix_compile/utils/paths.py
from pathlib import Path
from platformdirs import PlatformDirs

# 定义 App 名称，这决定了文件夹的名字
APP_NAME = "fix-compile"
APP_AUTHOR = "your-name" # Windows 需要

dirs = PlatformDirs(APP_NAME, APP_AUTHOR)

def get_config_dir() -> Path:
    """获取配置目录，并自动创建"""
    path = Path(dirs.user_config_dir)
    path.mkdir(parents=True, exist_ok=True)
    return path

def get_cache_dir() -> Path:
    """获取缓存目录"""
    path = Path(dirs.user_cache_dir)
    path.mkdir(parents=True, exist_ok=True)
    return path

def get_log_dir() -> Path:
    """获取日志目录"""
    path = Path(dirs.user_log_dir)
    path.mkdir(parents=True, exist_ok=True)
    return path

# 用法示例
# from .utils.paths import get_log_dir
# log_file = get_log_dir() / "app.log"

```

---

### 四、 真正的“临时文件” (Temporary Files)

如果你只是需要创建一个文件，用完马上就删（比如：构建 Docker 时把 Prompt 写入一个临时 JSON 文件传给 API，或者解压一个 Zip 包），不要用上面的目录。

使用 Python 标准库 **`tempfile`**。

```python
import tempfile
import os

# 1. 自动创建一个临时文件，关闭后自动删除
with tempfile.NamedTemporaryFile(suffix=".json", delete=True) as tmp:
    tmp.write(b'{"foo": "bar"}')
    tmp.flush()
    # 传给 subprocess 用
    print(f"临时文件路径: {tmp.name}")
    # ... do something ...

# 2. 创建一个临时目录
with tempfile.TemporaryDirectory() as tmp_dir:
    print(f"临时构建目录: {tmp_dir}")
    # 在里面随便写文件，with 结束整个目录自动 rm -rf

```

### 总结

1. **Repo 结构**：遵循 `src-layout`，把非 Python 的 demo 放 `examples/`。
2. **内置资源**：放 `src/fix_compile/templates/`，用 `importlib.resources` 读取。
3. **持久化配置/数据**：用 `platformdirs` 获取系统标准路径。
4. **一次性垃圾**：用 `tempfile` 模块，让操作系统自动清理。
