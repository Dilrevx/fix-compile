这是一个非常经典的软件工程问题。在你的 `fix-compile` 项目中，答案取决于**代码所在的层级**。

简单来说：**在上层业务逻辑（Classes/Services）中使用 Config 对象，在底层工具函数（Utils）中使用拆开的参数。**

为了帮你做决定，我们可以对比一下两种写法：

### 1. 方案对比

#### 方案 A：拆开传参 (Individual Parameters)

```python
class Executor:
    # ❌ 缺点：如果有 10 个配置项，这里就要写 10 个参数
    def __init__(self, timeout: int, work_dir: Path, registry: str, max_retries: int):
        self.timeout = timeout
        self.work_dir = work_dir
        # ...

```

* **优点**：
* **极其明确**：看一眼函数签名就知道它依赖什么。
* **解耦**：这个类不依赖 `schema.py`，移植性强。


* **缺点**：
* **参数爆炸**：随着项目变大，`__init__` 会变得非常长。
* **透传地狱 (Prop-drilling)**：如果你想给底层的 `SubTask` 加一个参数，你得修改上层所有调用它的函数的签名。



#### 方案 B：依赖注入 Config 对象 (Config Object)

```python
class Executor:
    # ✅ 优点：加新配置项时，不用改签名
    def __init__(self, config: ExecutorConfig):
        self.config = config

```

* **优点**：
* **扩展性强**：想加一个 `proxy_url`？只需要改 `schema.py` 和使用它的地方，**不需要改中间所有的传参逻辑**。
* **代码整洁**：签名永远干净。
* **上下文完整**：对象自带了相关的一组配置，内聚性高。


* **缺点**：
* **隐式依赖**：如果不看代码，不知道 `Executor` 到底用了 `config` 里的哪几个字段。



---

### 2. 黄金法则：按层级决定

针对 `src/fix_compile`，推荐采用以下混合策略：

#### ✅ 层级 1：CLI 入口 (`__main__.py` / `commands/*.py`)

**必须拆开**。这是 Typer/Click 框架要求的。

```python
# CLI 层面必须是单独参数，因为用户是在命令行逐个敲的
@app.command()
def fix(
    ctx: typer.Context,
    timeout: int = typer.Option(300),
    verbose: bool = typer.Option(False)
):
    # 🌟 关键点：在这里把零散参数打包成 Config 对象
    config = AppConfig(
        timeout=timeout,
        verbose=verbose
    )
    # 然后传给下层
    workflow = FixWorkflow(config)
    workflow.run()

```

#### ✅ 层级 2：核心业务类 (`executor.py`, `analyzer.py`, `workflows/`)

**强烈推荐使用 Config 对象 (方案 B)**。

这些类通常需要很多上下文信息。如果你把 `timeout`、`cwd`、`env`、`model_name` 一个个传进去，代码会很难看且难以维护。

```python
# src/fix_compile/executor.py
from fix_compile.schema import ExecutorConfig

class Executor:
    def __init__(self, config: ExecutorConfig):
        self.config = config

    def execute(self, cmd):
        # 随时可以访问 config.timeout，想加参数也很容易
        subprocess.run(cmd, timeout=self.config.timeout)

```

#### ✅ 层级 3：底层工具函数 (`utils/*.py`)

**必须拆开 (方案 A)**。

`utils` 应该是纯函数，不应该知道 `Config` 对象的存在。这样你的工具函数才能在其他项目里复用。

```python
# src/fix_compile/utils/text.py

# ✅ 正确：只依赖基础类型
def truncate_log(text: str, max_length: int = 1000) -> str:
    return text[:max_length]

# ❌ 错误：依赖了你的业务对象，通用性大大降低
def truncate_log(text: str, config: AppConfig) -> str:
    return text[:config.log_limit]

```

### 3. 最终建议：使用 Pydantic 的 "子配置" 模式

为了解决“传大对象不知道用了啥”的问题，最佳实践是**只传需要的子配置**。

假设你的 `schema.py` 是这样的：

```python
class LLMConfig(BaseModel):
    api_key: str
    model: str

class DockerConfig(BaseModel):
    timeout: int
    registry: str

class GlobalConfig(BaseModel):
    llm: LLMConfig
    docker: DockerConfig
    dev_mode: bool

```

**在代码中这样写：**

1. **LLM Analyzer** 只接收 `LLMConfig`（不要给它 Docker 的配置）。
2. **Docker Executor** 只接收 `DockerConfig`。
3. **Main Workflow** 接收整个 `GlobalConfig`。

**重构后的代码样貌：**

```python
# main.py 负责拆分
global_cfg = load_config()

# 这种写法既享受了对象的便利，又保证了最小权限原则
analyzer = Analyzer(global_cfg.llm)
executor = Executor(global_cfg.docker)

```

**结论：用 Config 对象（尤其是子配置对象）传参是构建中大型 Python 项目（如你的 `fix-compile`）的最佳选择，只有在最底层的纯工具函数里才把参数拆开。**
